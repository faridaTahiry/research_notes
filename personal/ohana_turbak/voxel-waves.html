<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Voxel Test</title>
        <script id = "gl-matrix" src="gl-matrix.js"></script>
        <!--- 2 triangles screenspace vert shader-->
        <script id="2d-vertex-shader" type="x-shader/x-vertex">#version 300 es
            in vec2 a_position;
            uniform vec2 screenRatio;

            void main() {
               gl_Position = vec4(a_position, 0, 1);
            }
            </script>

        <!--raymarching frag -->
        <script id="raymarch-frag-shader" type="x-shader/x-fragment">#version 300 es
            precision mediump float;
            precision mediump sampler3D;
            #define NUM_VOXELS 90000 
            #define X_VOXELS (60.)
            #define Y_VOXELS (25.)
            #define Z_VOXELS (60.)  // float 
        
            uniform vec2 resolution;
            uniform vec3 globalUp;            
            uniform vec3 cameraPos;
            uniform vec3 camLookAt;
            uniform float FOV;
            //uniform float nearClip;
            //uniform float farClip;

            uniform float time;
                   
            uniform sampler3D u_texture;

            out vec4 outputColor;
        
        
            
            //ray-cube intersection bounding box: adapted from source http://ray-tracing-conept.blogspot.com/2015/01/ray-box-intersection-and-normal.html
            
            float intersectCube(vec3 rayStart, vec3 normalizedRayDirection, float rayLength, vec3 b1, vec3 b2){
            //float intersectCube(vec3 normalizedRayDirection, float rayLength, vec3 rayStart){
                vec3 rayDirection = normalizedRayDirection * rayLength;
                float t1;
                float t2;
                float tnear = -1.; //arbitrary negative number?
                float tfar = 1.1; //because distances can't (I think) exceed 1
                float temp;
                float tCube;
                bool intersectFlag = true;
                for(int i =0 ;i < 3; i++){ //x, y, z
                    if(rayDirection[i] == 0.){ //cant divide by zero
                        if(rayStart[i] < b1[i] || rayStart[i] > b2[i]) {
                            intersectFlag = false;
                        }
                    }
                    else{ //closer % of line traveled in one dimension = closer, *not* actual distance in 1 dimension because that's not representative of *ray* distance
                        t1 = (b1[i] - rayStart[i])/rayDirection[i]; //find where line intersects (near)plane of axis (in terms of % of legnth traveled in 1 dimension)
                        t2 = (b2[i] - rayStart[i])/rayDirection[i]; //find where line intersects (far)plane of axis
                        if(t1 > t2){ //swap t1 and t2 so t1 is smaller
                            temp = t1;
                            t1 = t2;
                            t2 = temp;
                        }
                        if(t1 > tnear) {tnear = t1; } //find largest tnear
                        if(t2 < tfar) {tfar = t2; } //find smallest tfar
                        if(tnear > tfar) { intersectFlag = false; } //line doesn't intersect if furthest "near" is further than closest "far"
                        if(tfar < 0.) { intersectFlag = false; } //BB is before origin
                    }
                }
                if(intersectFlag == false) {
                    tCube = -1.;
                }
                else {
                    tCube =  tnear * rayLength;
                }
                
                return tCube;
            }
        
            //voxel defined by point in bottom corner such that the voxel at (0,0,0) goes up to not including (1,0,0) (0,1,0) (0,0,1) etc.
            //tutorials https://www.scratchapixel.com/lessons/advanced-rendering/introduction-acceleration-structure/grid
            //tutorials http://castingrays.blogspot.com/2014/01/voxel-rendering-using-discrete-ray.html
            
            vec4 ddaMarching (vec3 origin, vec3 dir) { //took out start, end
                //setup: calculate direction, [ray length to get from 0->1 for each axis]
                vec3 signs = sign(dir);
                vec3 tDelta = abs(vec3(1./dir.x, 1./dir.y, 1./dir.z)); //scratchapixel for explanation
                vec3 voxelCoords = vec3(floor(origin.xyz)); //what voxel we start in
                vec3 startOffset = vec3(origin - voxelCoords);
                vec3 isPos = vec3(0.5*signs + 0.5); //1 = pos, 0 = neg
                vec3 distToNext = abs(vec3( ((isPos.x) - startOffset.x)/dir.x,  //handles pos and neg
                                            ((isPos.y) - startOffset.y)/dir.y, 
                                            ((isPos.z) - startOffset.z)/dir.z));       
        
                //because of bounding box, assume camera is never *in* voxel. so, check starting voxel for hit before looping
                vec4 currentVoxel = texelFetch(u_texture, ivec3(voxelCoords.x, voxelCoords.y, voxelCoords.z),0);
                 if (currentVoxel.r > 0.) {
                    return vec4(voxelCoords, currentVoxel.r);
                 }
                //int currentVoxel = int(voxelCoords.x + voxelCoords.z * CR_VOXELS + voxelCoords.y * CR_VOXELS * CR_VOXELS); //x,z,y, order for now cause it works in my head

        
        
                while (true) {  
                    if(distToNext.x < min(distToNext.y, distToNext.z)){
                        distToNext.x += tDelta.x; //distToNext = TOTAL distance from origin
                        voxelCoords.x += signs.x;
                    }
                    else if(distToNext.y < distToNext.z){ //double check this
                        distToNext.y += tDelta.y;
                        voxelCoords.y += signs.y;
                    }
                    else {
                        distToNext.z += tDelta.z;
                        voxelCoords.z += signs.z;
                    }
                    if (   voxelCoords.x >= X_VOXELS || voxelCoords.x < 0. 
                        || voxelCoords.y >= Y_VOXELS || voxelCoords.y < 0. 
                        || voxelCoords.z >= Z_VOXELS || voxelCoords.z < 0.) { 
                        break;
                    }
        
                    currentVoxel = texelFetch(u_texture, ivec3(voxelCoords.x, voxelCoords.y, voxelCoords.z),0);
                    if (currentVoxel.r > 0.) {
                        return vec4(voxelCoords, currentVoxel.r);
                    }

                }
                //else
                return vec4(0.0, 0.0, 0.0, 0.0);
            }
        
            void main() {
        
                //setup screen coords
                //converts from pixels from bottom left to centered at (0,0) from [-1,1]
                vec2 aspect = vec2(resolution.x/resolution.y, 1.0);
                vec2 screenCoords = (2.0*gl_FragCoord.xy/resolution.xy - 1.0)*aspect;
        
        
                
                //setup camera

        
                vec3 camPos = cameraPos; //calculated in cpu

                //basically define up, forward, right in relation to camera; camera-relative coords
                vec3 forward = normalize(camLookAt-camPos);
                vec3 right = normalize(cross(globalUp, forward));
                vec3 up = normalize(cross(forward,right));
        
                //ray origin/direction
                vec3 rayOrigin = camPos; //originally 'ro'
                vec3 rayDirection =  normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up); //originally 'rd', fairly standard (not minus camPos cause forward already did that)
        
        
                //optional background shading
                //vec3 bgColor = vec3(0.38, 0.75, 0.95);
                vec3 bgColor = vec3(1.,0.82, 0.43);
        
                float intersectDist = intersectCube(rayOrigin, rayDirection, 500., vec3(0.001, 0.001, 0.001), vec3(X_VOXELS-.001, Y_VOXELS-.001, Z_VOXELS-.001));     
                //float intersectDist = intersectCube(rayDirection, 50., rayOrigin);     
                vec3 intersectPoint = rayOrigin + (rayDirection * intersectDist);
        
                if (intersectDist <= -1.) {
                    //outputColor = vec4(bgColor, 1.0);
                    //outputColor = vec4(1.,0.90, 0.55, 1.1-abs(0.5*sin(screenCoords.x+1.57)*cos(screenCoords.y)));
                    outputColor = vec4(bgColor - 0.3 + abs(0.9*sin(screenCoords.x+1.57)*cos(screenCoords.y)), 1.);
 
                    return;
                }
        
                vec4 hitVoxel = ddaMarching(intersectPoint, rayDirection); 
                //if past clip planes, return bg color
                if ( hitVoxel.a != 0. ) {
                   // outputColor = vec4(.05*hitVoxel.y*(1.-(60./distance(hitVoxel.xyz, camPos))), (hitVoxel.y/40.)+0.15*fract(abs(sin(rayDirection.y*intersectDist*1000.)*cos(1234.*rayDirection.z*time)*2.)), hitVoxel.y/23., 1+ //1. - (12./distance(hitVoxel.xyz, camPos))); //random wave surface (CR_VOXELS = 40)
                    outputColor = vec4(.05*hitVoxel.y*(1.-(60./distance(hitVoxel.xyz, camPos))), (0.8+sin(4.*time)/5.)*(hitVoxel.y/23.), hitVoxel.y/19., 1.) + max(0., (hitVoxel.y-14.)/8.);
                    // + 10.*(hitVoxel.y)); //(12./distance(hitVoxel.xyz, camPos))); //random wave surface (CR_VOXELS = 40)
                    return;        
                }
               
        
                else {
                    //outputColor = vec4(bgColor, 1.0);
                    //outputColor = vec4(mix(vec3(1., 1., 1.), bgColor, 1.2-abs(1.*sin(screenCoords.x+1.57)*cos(screenCoords.y))), 1.);
                    outputColor = vec4(bgColor - 0.3 + abs(0.9*sin(screenCoords.x+1.57)*cos(screenCoords.y)), 1.);   
                }
            }
        </script>
        
        
        <!---->
        <script src="1-voxel-waves/1-voxel-waves-program.js"></script>
    </head>
        <style>
            body {
            font-family:"Trebuchet MS", Helvetica, sans-serif;
              background-color: rgb(33, 36, 44);
            }
            
            h1 {
              color: rgb(255, 210, 111);
            }
            h2 {
                color: rgb(137, 202, 255);
            }
            h3 {
                font-family:Verdana, Geneva, sans-serif;
                font-weight: normal;
                color: rgb(69, 123, 204);
            }
            h4 {
                font-family:Verdana, Geneva, sans-serif;
                font-weight: normal;
                color: rgb(69, 123, 204);
            }
            p, ul {
                font-family:Verdana, Geneva, sans-serif;
                font-size:87%;
                line-height: 122%;
                color: rgb(190, 196, 211);
            }
            a:link {
                color: rgb(245, 188, 122);
            }

            a:visited {
                color: rgb(238, 136, 96);
            }
            a:hover {
                color: rgb(238, 136, 96);
                text-decoration: none;
            }
            /*** Works on common browsers ***/
            ::selection {
                background-color: rgb(190, 196, 211);
                color:rgb(33, 36, 44);
            }

            /*** Mozilla based browsers ***/
            ::-moz-selection {
                background-color: rgb(190, 196, 211);
                color:rgb(33, 36, 44);
            }
            </style>
    <body onload = "runTest();">
        <h1 style="padding:0px 50px;"id="test-header">Voxel Renderer</h1>
        <h3 style="padding:0px 75px;"id="test-header">Interactive WebGL Demo</h3>
        <div style="padding:0px 75px;">

            <div style = "padding:5px 25px;">
                <canvas id="glCanvas" width="640" height="480"></canvas>
                <p id="info">Frames:</p>
            </div>
            <h2 id="test-footer">Instructions</h2>
            <p style="padding:0px 25px;">Click the screen, then drag the mouse within the canvas to move the camera. Zoom in and out by scrolling.  
                To toggle between rotation and click-and-drag mode, press 'r' or spacebar.  </p>
            <h2 id="test-footer">About</h2>
            <div style="padding:0px 25px;">
                <p>This is a voxel renderer written entirely in the fragment shader.  The word 'voxel' stands for 'volume element' in the same way that 
                    'pixel' stands for 'pixel element', and voxels are essentially cubes.  The world is represented as a 3D grid, where each cube in the grid
                    can be empty or full. Currently, voxels are stored as a 3D array the size of the grid, and each element in the array is either on or off.
                </p> 
                <p>The graphics pipeline typically works by passing polygon vertices to the 'vertex shader', which projects 3D vertices onto 2D screen space.
                    Then, the 'fragment shader' determines the color of each pixel.  Since I am not using vertices/triangles to represent positions, I do things differently.
                    You have to pass in vertices, so I pass 2 triangles that cover the full screen to the vertex shader.  Then, I pass the voxel position data to the 
                    fragment shader as a 3D texture.  Within the fragment shader, I setup a virtual 'camera,' and render everything by sending out rays from the camera origin 
                    through each pixel, and detect if they pass through a voxel.
                </p>
                <p> To do this, first I place the entire voxel grid within a cube, and then detect if a ray hits that cube.  If it doesn't, it can't hit a voxel, and therefore 
                    draws the background color.  (This is called a 'bounding box' technique.)  If I do hit the bounding box, I use a rasterizing algorithm to detect if I hit a 
                    voxel.  'Rasterization' is converting a (continuous) vector into the discrete pixels or boxes it passes through. This is generally used to translate 
                    projected triangles into pixel graphics, but in my case, I use a 3D version to check every box a ray passes through for whether or not there is a voxel there.  
                    The specific algorithm I use is 3D-DDA (3D Digital Differential Analyzer), where you start at the origin of the ray and calculate the distance to the nearest 
                    next grid intersection(x, y, or z), then make that next intersection the new origin, and repeat.  At every origin, check for whether that box is empty, or if 
                    there is a voxel there (by checking the 3D texture data).  If there's a voxel, the function returns; otherwise, it continues until the ray leaves the bounding box
                    or exceeds some value.
                </p>   
                <p> If the ray intersected a voxel, the program calculates the color of the voxel, currently based on position and time.  If it did not intersect a voxel, the pixel is
                    drawn in the background color.
                </p> 
                <p> The waves in the above example are generated by turning voxels on and off in the CPU/javascript program based on added sine functions every frame, and the color
                    is done in the fragment shader.  Although it doesn't look super high resolution, the above example renders about 100,000 voxels.
                </p>     
                <p> I learned most of this through the internet, but here are some specific sites/resources that were very helpful:
                </p>
            </div>    
            <h4>Rendering in the fragment shader:</h4>
            <ul>
                <li><a href="http://iquilezles.org/www/material/nvscene2008/rwwtt.pdf">RWWTT.pdf</a> - "Rendering Worlds With Two Triangles."</li> 
                <li><a href="http://raymarching.com/">Raymarching.com</a> - Many examples of raymarching, click 'view page source' on a given demo to see the code and helpful comment tutorials.</li>
                <li><a href="http://ShaderToy.com">ShaderToy.com</a> - A site where anyone can upload and view fragment shaders</li>
            </ul>    
            <h4>Bounding box: </h4>
            <ul>
                <li><a href="https://www.youtube.com/watch?v=4h-jlOBsndU&list=PLMinhigDWz6emRKVkVIEAaePW7vtIkaIF&index=49">Ray intersects Bounding Box (AABB)</a> - a video tutorial</li>
                <li><a href="http://ray-tracing-conept.blogspot.com/2015/01/ray-box-intersection-and-normal.html">Ray-Box intersection</a> - a tutorial</li>
            </ul>
            <h4>3D-DDA:</h4>
            <ul>
                <li><a href="https://www.scratchapixel.com/lessons/advanced-rendering/introduction-acceleration-structure/grid">Grid Acceleration Structures</a> - very detailed explanation of the math behind 3D-DDA with diagrams and psuedocode </li>
                <li><a href="http://castingrays.blogspot.com/2014/01/voxel-rendering-using-discrete-ray.html">Voxel Rendering DDA</a> - also a tutorial on 3D-DDA, but aimed specifically at voxel rendering</li>            
            </ul>
        </div>
    </body>
</html>
