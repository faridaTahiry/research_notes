Technical Abstract: 

For my project, I created a voxel renderer which displays a simple 3D cellular automata based sand simulation. The word 'voxel' stands for 'volume element' in the same way that 'pixel' stands for 'picture element', and voxels are essentially cubes. The world is represented as a 3D grid, where each cube in the grid can be empty or full. Voxels are stored as a 3D array the size of the grid, and each element in the array is either on or off.

Usually, 3D scenes are created out of triangles or polygons, and displayed by using GPU programs called shaders to first project the position of the triangles into 2D space (the vertex shader), then determine the color of each pixel in each triangle (the fragment shader). Because I want the fundamental unit to be voxels, not polygons, I have to work around this pipeline.  Because the fragment shader actually determines the color of each pixel, I was able to write the full renderer within the fragment shader.  First, I pass in the voxel position data using a texture, and then I set up a virtual 'camera' and render everything by sending out rays from the camera origin through each pixel to detect if they pass through a voxel.

To do this, I first place the entire voxel grid within a bounding box.  If the ray hits the bounding box, I then use a 3D rasterization algorithm (3D Digital Differential Analyzer) to step through each box in the grid through which the ray passes.  At each grid intersection, it checks if that location contains a voxel.  If the ray intersected a voxel, the program calculates the color of the voxel, otherwise, the pixel is drawn in the background color.  Through this method it can render hundreds of thousands of voxels.

Once we have a functioning voxel renderer, we can manipulate the voxels for various simulation or aesthetic purposes.  For this project, I use it to simulate basic sand movement with cellular automata.  Each voxel represents a grain of sand.  The program checks or each voxel whether there is empty space beneath it; if so, the sand "falls" by changing the current voxel to be empty, and the one below to be full.  Since sand spreads out until it reaches a particular slope, the program also checks for empty space below and the sides of the voxel, and randomly "moves" the voxel to one of the empty spots if one is available. 
